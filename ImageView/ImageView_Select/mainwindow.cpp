#include "mainwindow.h"
#include "ui_mainwindow.h"


MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow),
    ImReader(new ImageReader),
    CurrentImage(new QImage),
    ImageScene(new myScene(QSize(rec_width,rec_height),this)),
    ROIScene(new QGraphicsScene(this))
{
    ui->setupUi(this);

    rec_width = 24;
    rec_height = 24;

    /*set the initial size of ROIwindos*/
    ui->ROIheightlineEdit->setText(QString::number(rec_width));
    ui->ROIwidthlineEdit->setText(QString::number(rec_height));

//    QRegExp rx("^[1-9]*[1-9][0-9]*$");
//    QValidator *validator = new QRegExpValidator(rx, this);
//    ui->ROIheightlineEdit->setValidator(validator);
//    ui->ROIwidthlineEdit->setValidator(validator);

    /*set the Edit in DISABLED status*/

    ui->ROIheightlineEdit->setEnabled(false);
    ui->ROIwidthlineEdit->setEnabled(false);

    /*set the reguler expression for the PrefixEdit*/
    QRegExp filenamerx("^[^\\\\/:*?\"<>|.]*$");
    QValidator *filenamevalidator = new QRegExpValidator(filenamerx, this);
    ui->ROIPrefixEdit->setValidator(filenamevalidator);
    /*limit the length of the prefix-name*/
    ui->ROIPrefixEdit->setMaxLength(20);

    /*put the Scenes in the Views about ROI and Image*/
    ui->ImageView->setScene(ImageScene);
    ui->ROIView->setScene(ROIScene);

    ui->TypeBox->addItem("jpg");
    ui->TypeBox->addItem("bmp");
    ui->TypeBox->addItem("png");
}

MainWindow::~MainWindow()
{
    delete ui;
}
/*this is the slot connnected with the actionOpen's signel generated by triggered*/
void MainWindow::on_actionOpen_triggered()
{
    /*popup a Qfiledialog ,choosing a file and return the image's fullpath*/
    myPath.ImagePath = ImReader->getFilePath();

    if(myPath.ImagePath.isEmpty()){
        return;
    }

    /*try to load the image by the fullpath into the CurrentImage*/
    if(!ImReader->loadFile<QImage>(myPath.ImagePath,CurrentImage)){
        sendinfo(tr("Error:Open %1 failed!").arg(myPath.ImagePath));
    }
    /*if the image is vaild,set the path into the class QFileInfo to anlyize the path*/
    myImage.setFile(myPath.ImagePath);

    mySearchdir = myImage.dir();
    sendstatus(tr("Folder Path is %1").arg(myImage.absolutePath()));

    /*add the CurrentImage into the ImageScene*/
    /*set the Scene 's rectrangle which surround the Scene's boundary */
    auto imagewidth = CurrentImage->width();
    auto imageheight = CurrentImage->height();

    ImageScene->addPixmap(QPixmap::fromImage(*CurrentImage));
    ImageScene->setSceneRect(0,0,imagewidth,imageheight);
    /*store the CurrentImage 's Size */
    myPath.ImageSize = CurrentImage->size();

    /*activate the button */
    ui->SetROIButton->setEnabled(true);
    ui->ROIheightlineEdit->setEnabled(true);
    ui->ROIwidthlineEdit->setEnabled(true);
    /*set the inputEdit 's limit*/
    ui->ROIwidthlineEdit->setValidator(new QIntValidator(0,imagewidth,this));
    ui->ROIheightlineEdit->setValidator(new QIntValidator(0,imageheight,this));

    /*set the placeholder Text which is decided by maximum size of input image */
    ui->ROIwidthlineEdit->setPlaceholderText(tr("MaxWidth %1").arg(imagewidth));
    ui->ROIheightlineEdit->setPlaceholderText(tr("MaxHeight %1").arg(imageheight));
}

void MainWindow::on_ROIwidthlineEdit_textChanged(const QString &arg1)
{
    auto height = ui->ROIheightlineEdit->text().isEmpty() == true ? 0 : ui->ROIheightlineEdit->text().toInt();
    setROISize(QSize(arg1.isEmpty() == true ? 0 : arg1.toInt(),height));
}

void MainWindow::on_ROIheightlineEdit_textChanged(const QString &arg1)
{
    auto width = ui->ROIwidthlineEdit->text().isEmpty() == true ? 0 : ui->ROIwidthlineEdit->text().toInt();
    setROISize(QSize(width,arg1.isEmpty() == true ? 0 : arg1.toInt()));
}


void MainWindow::on_SetROIButton_clicked()
{
    QList<QGraphicsItem *> itemlist = ImageScene->items();
    if(itemlist.isEmpty() || (itemlist.count() == 2)){
        return;
    }
    static bool down = false;
    if(down == true){
        qDebug()<<"ture";
        ImageScene->setMode(myScene::Sleep);
        down = false;
        ui->SetROIButton->setDown(false);
    }
    else{
        qDebug()<<"false";
        ImageScene->setMode(myScene::InsertItem);
        down = true;
        ui->SetROIButton->setDown(true);
    }
}

void MainWindow::sendstatus(const QString &arg1)
{

    ui->statusBar->showMessage(arg1);
}


void MainWindow::setROISize(QSize roiSize)
{
//    qDebug()<<"win setRoisize"<<roiSize;
    ImageScene->setROISize(roiSize);
}

void MainWindow::updateROIImage(QRectF rectangle)
{
    ROIRec = rectangle.toRect();
    ROIScene->clear();
    ROIScene->addPixmap(QPixmap::fromImage(CurrentImage->copy(ROIRec)));
    ROIScene->setSceneRect(0,0,rectangle.width(),rectangle.height());
}

void MainWindow::sendinfo(const QString &arg1)
{
    ui->infoBrowser->append(arg1 + " [" + QDateTime::currentDateTime().time().toString() + "]");
}

void MainWindow::on_SaveROIButton_clicked()
{
    if(myPath.SavePath.isEmpty()){
        sendinfo("Error:Needed a Saving Path");
        return;
    }
    QList<QGraphicsItem *> itemlist = ImageScene->items();
    if(itemlist.isEmpty()){
        sendinfo("Error:Needed to select a ROI");
        return;
    }
    if(ROIRec.width() == 0 && ROIRec.height() == 0){
        return;
    }
    if(myPath.ImageSaveName.isEmpty()){
        CurrentImage->copy(ROIRec).save(myPath.SavePath + "/" + myImage.baseName()
                                        + "_" + QString::number(savecounts) + "." + myPath.ImageType);
    }
    else{
        CurrentImage->copy(ROIRec).save(myPath.SavePath + "/" + myPath.ImageSaveName
                                        + "_" + QString::number(savecounts) + "." + myPath.ImageType);
    }
    savecounts++;
}

void MainWindow::on_actionOpenFolder_triggered()
{
    QString tempfolderpath = ImReader->getFolderPath();
    if (tempfolderpath.isEmpty())
        return;
    myPath.FolderPath = tempfolderpath;
}

void MainWindow::on_actionSetSavePath_triggered()
{
    QString tempfolderpath = ImReader->getFolderPath();
    if (tempfolderpath.isEmpty())
        return;

    myPath.SavePath = tempfolderpath;
}

void MainWindow::on_ROIPrefixEdit_textChanged(const QString &arg1)
{
    myPath.ImageSaveName = arg1;
    savecounts = 0;
}
/*right-hand button signal-slot function*/
void MainWindow::on_infoBrowser_customContextMenuRequested(const QPoint &pos)
{
    ui->infoBrowser->cmenu->exec(QCursor::pos());
}

void MainWindow::on_ImageView_customContextMenuRequested(const QPoint &pos)
{
    ui->ImageView->cmenu->exec(QCursor::pos());
}

void MainWindow::on_actionDrag_triggered()
{
    static bool down = false;
    if(down == true){
        ui->actionDrag->setIcon(QIcon(":/icon/icon/hand_black.png"));
        ui->ImageView->setDragMode(myImageView::DragMode::NoDrag);
        down = false;
        ui->actionDrag->setChecked(false);
    }
    else{
        ui->actionDrag->setIcon(QIcon(":/icon/icon/hand_blue.png"));
        ui->ImageView->setDragMode(myImageView::DragMode::ScrollHandDrag);
        down = true;
        ui->actionDrag->setChecked(true);
    }
}

void MainWindow::on_NextButton_clicked()
{
    /*check whether the ImagePath is empty that equals checking the CurrentImage whether valid  */
    if(myPath.ImagePath.isEmpty()){
        return;
    }
    /*entryInfoList return a list of all the files from the path you set and filtered by the type filter which you set */
    QFileInfoList infolist  = mySearchdir.entryInfoList(QStringList() << "*.jpg" << "*.png" << "*.bmp");
    int idx{0};
    /*start iteration to orient the file's position in the path you seted  */
    foreach (QFileInfo fileinfo, infolist) {
        if( fileinfo.baseName() == myImage.baseName() ){
            break;
        }
        idx++;
    }
    /*move the pos to the next file */
    ++idx;
    /*check whether the pos is the last one */
    if(idx > (infolist.count()-1)){
        sendinfo(tr("Warn:It's a last image"));
        return;
    }
    /*set the new ImagePath */
    myImage = infolist.at(idx);

    myPath.ImagePath = myImage.filePath();

    if(myPath.ImagePath.isEmpty()){
        return;
    }
    /*try to load the image by the fullpath into the CurrentImage*/
    if(!ImReader->loadFile<QImage>(myPath.ImagePath,CurrentImage)){
        sendinfo(tr("Error:Open %1 failed!").arg(myPath.ImagePath));
    }
    /*initialize the Scenes */
    ROIRec.setSize(QSize(0,0));
    ImageScene->clear();
    ROIScene->clear();
    /*set the Searchdir*/
    mySearchdir.setPath(myImage.path());

    sendstatus(tr("Folder Path is %1").arg(myImage.absolutePath()));

    /*put the image into the Scene and adjust the size of Scene */
    ImageScene->addPixmap(QPixmap::fromImage(*CurrentImage));
    ImageScene->setSceneRect(0,0,CurrentImage->width(),CurrentImage->height());

    myPath.ImageSize = CurrentImage->size();
}

void MainWindow::on_PrevButton_clicked()
{
    if(myPath.ImagePath.isEmpty()){
        return;
    }

    QFileInfoList infolist  = mySearchdir.entryInfoList(QStringList() << "*.jpg" << "*.png" << "*.bmp");
    int idx{0};
    foreach (QFileInfo fileinfo, infolist) {
        if( fileinfo.baseName() == myImage.baseName() ){
            break;
        }
        idx++;
    }
    --idx;
    if(idx < 0){
        sendinfo(tr("Warn:It's the first image"));
        return;
    }

    myImage = infolist.at(idx);

    myPath.ImagePath = myImage.filePath();

    if(myPath.ImagePath.isEmpty()){
        return;
    }
    if(!ImReader->loadFile<QImage>(myPath.ImagePath,CurrentImage)){
        sendinfo(tr("Error:Open %1 failed!").arg(myPath.ImagePath));
    }
    ROIRec.setSize(QSize(0,0));
    ImageScene->clear();
    ROIScene->clear();

    mySearchdir.setPath(myImage.path());

    sendstatus(tr("Folder Path is %1").arg(myImage.absolutePath()));

    ImageScene->addPixmap(QPixmap::fromImage(*CurrentImage));
    ImageScene->setSceneRect(0,0,CurrentImage->width(),CurrentImage->height());

    myPath.ImageSize = CurrentImage->size();
}

void MainWindow::on_TypeBox_currentIndexChanged(const QString &arg1)
{
    myPath.ImageType = arg1;
}

void MainWindow::on_SetROIButton_released()
{

}

void MainWindow::on_actionZoomOut_triggered()
{

}
